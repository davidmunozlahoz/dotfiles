### BINARY OPERATORS SNIPPETS ###

global !p
def math():
	return vim.eval('vimtex#syntax#in_mathzone()') == '1'
endglobal

context "math()"
snippet => "implies" Ai
\implies
endsnippet

context "math()"
snippet =< "implied by" Ai
\impliedby
endsnippet

context "math()"
snippet iff "iff" Ai
\Leftrightarrow
endsnippet

context "math()"
snippet != "equals" iA
\neq 
endsnippet

context "math()"
snippet <= "leq" iA
\le 
endsnippet

context "math()"
snippet >= "geq" iA
\ge 
endsnippet

context "math()"
snippet +- "Plus Minus" iA
\pm
endsnippet

context "math()"
snippet -+ "Minus Plus" iA
\mp
endsnippet

context "math()"
snippet xx "cross product" iA
\times 
endsnippet

context "math()"
priority 100
snippet ** "dot product" iA
\cdot 
endsnippet

priority 100
context "math()"
snippet -> "to" iA
\to 
endsnippet

priority 200
context "math()"
snippet <-> "leftrightarrow" iA
\leftrightarrow
endsnippet

context "math()"
snippet !> "mapsto" iA
\mapsto 
endsnippet

context "math()"
snippet \\\ "setminus" iA
\setminus
endsnippet

context "math()"
snippet >> ">>" iA
\gg
endsnippet

context "math()"
snippet << "<<" iA
\ll
endsnippet

context "math()"
snippet ~~ "~" iA
\sim 
endsnippet

context "math()"
snippet ~= "Congruent tilde" Ai
\cong
endsnippet

context "math()"
snippet := "Definition" iA
\coloneqq
endsnippet

context "math()"
snippet || "mid" iA
\mid 
endsnippet

context "math()"
snippet cc "subset" Ai
\subseteq 
endsnippet

context "math()"
snippet notin "not in " iA
\not\in 
endsnippet

context "math()"
snippet inn "in " iA
\in 
endsnippet

context "math()"
snippet Nn "cap" iA
\cap 
endsnippet

context "math()"
snippet UU "cup" iA
\cup 
endsnippet

context "math()"
snippet uuu "bigcup" iA
\bigcup_{${1:i \in ${2: I}}} $0
endsnippet

context "math()"
snippet nnn "bigcap" iA
\bigcap_{${1:i \in ${2: I}}} $0
endsnippet

context "math()"
snippet <! "normal" iA
\triangleleft 
endsnippet
